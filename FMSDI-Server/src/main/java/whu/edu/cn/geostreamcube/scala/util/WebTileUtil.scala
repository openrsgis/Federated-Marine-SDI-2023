package whu.edu.cn.geostreamcube.scala.util

import geotrellis.vector.Extent
import org.locationtech.jts.geom.{Geometry, GeometryCollection, GeometryFactory}
import redis.clients.jedis.Jedis

import scala.collection.mutable

/**
 * Z 曲线编码相关的一些转换工具
 * Morton 码
 */
object WebTileUtil {

  /**
   * Determining whether the web tiles need to be computed
   *
   * @param taskID      the taskID generated by the web
   * @param level       the level of the web window
   * @param windowRange the spatial extent of the web window
   * @return Precise spatial extent for query
   */
  def judgeWebTile(taskID: String, level: Int, windowRange: String): String = {
    val zIndexStrArray = new mutable.ArrayBuffer[String]
    val lonLatsOfWindow: Array[Double] = windowRange
      .substring(1, windowRange.length - 1).split(",").map(_.toDouble)
    println("lonLatsOfWindow = " + lonLatsOfWindow.mkString("Array(", ", ", ")"))

    val jedisUtil = new JedisUtil
    val jedis: Jedis = jedisUtil.getJedis
    val key: String = taskID + "solvedTile:" + level
    jedis.select(2)

    val xMinOfTile: Int = lon2Tile(lonLatsOfWindow.head, level)
    val xMaxOfTile: Int = lon2Tile(lonLatsOfWindow(2), level)
    val yMinOfTile: Int = lat2Tile(lonLatsOfWindow.last, level)
    val yMaxOfTile: Int = lat2Tile(lonLatsOfWindow(1), level)
    System.out.println("xMinOfTile - xMaxOfTile" + xMinOfTile + "-" + xMaxOfTile)
    System.out.println("yMinOfTile - yMaxOfTile" + yMinOfTile + "-" + yMaxOfTile)

    for (y <- yMinOfTile to yMaxOfTile; x <- xMinOfTile to xMaxOfTile
         if !jedis.sismember(key, xyToZCurve(Array[Int](x, y), level))
      // 排除 redis 已经存在的前端瓦片编码
         ) { // redis里存在当前的索引
      // Redis 里没有的前端瓦片编码
      val zIndexStr: String = xyToZCurve(Array[Int](x, y), level)
      zIndexStrArray.append(zIndexStr)
      // 将这些新的瓦片编号存到 Redis
      jedis.sadd(key, zIndexStr)
      jedis.expire(key, ConstantUtil.REDIS_CACHE_TTL)
    }

    jedis.close()
    if (zIndexStrArray.isEmpty) {
      println("窗口范围无明显变化，没有新的瓦片待计算")
      null
    }
    else {
      val queryExtent = new mutable.ArrayBuffer[Array[Double]]()

      for (zIndexStr <- zIndexStrArray) {
        val xy: Array[Int] = zCurveToXY(zIndexStr, level)
        val lonMinOfTile: Double = tile2Lon(xy(0), level)
        val latMinOfTile: Double = tile2Lat(xy(1) + 1, level)
        val lonMaxOfTile: Double = tile2Lon(xy(0) + 1, level)
        val latMaxOfTile: Double = tile2Lat(xy(1), level)
        queryExtent.append(Array(lonMinOfTile, latMinOfTile, lonMaxOfTile, latMaxOfTile))
      }
      val geometries: Array[Geometry] = queryExtent.map(extent => {
        val minX: Double = extent(0)
        val minY: Double = extent(1)
        val maxX: Double = extent(2)
        val maxY: Double = extent(3)
        val wkt: String = "POLYGON((" + minX + " " + minY + "," + minX + " " + maxY + "," + maxX + " " + maxY + "," + maxX + " " + minY + "," + minX + " " + minY + "))"
        val polygon: Geometry = geotrellis.vector.io.wkt.WKT.read(wkt)
        polygon
      }).toArray
      val geometryFactory: GeometryFactory = new GeometryFactory()
      val geometryCollection: GeometryCollection = geometryFactory.createGeometryCollection(geometries)
      geotrellis.vector.io.wkt.WKT.write(geometryCollection.union())
    }
  }

  def lonLatToZCurve(lon: Double, lat: Double, zoom: Int): String = xyToZCurve(lonLatToXY(lon, lat, zoom), zoom)

  /**
   * 经纬度转瓦片行列编号
   *
   * @param lon  经度
   * @param lat  维度
   * @param zoom 层级
   * @return x y
   */
  def lonLatToXY(lon: Double, lat: Double, zoom: Int): Array[Int] = {
    val n: Double = Math.pow(2, zoom)
    val tileX: Double = ((lon + 180) / 360) * n
    val tileY: Double = (1 - (Math.log(Math.tan(Math.toRadians(lat)) + (1 / Math.cos(Math.toRadians(lat)))) / Math.PI)) / 2 * n
    val xy: Array[Int] = Array[Int](Math.floor(tileX).toInt, Math.floor(tileY).toInt)
    System.out.println(xy(0) + "??? " + xy(1))
    xy
  }

  /**
   * 对行列编号进行Z曲线编码
   *
   * @param xy   行列 x y
   * @param zoom 层级
   * @return 编码结果
   */
  def xyToZCurve(xy: Array[Int], zoom: Int): String = { // Calculate the z-order by bit shuffling
    var res = 0
    for (i <- 0 until 2) {
      for (j <- 0 until zoom) {
        val mask: Int = 1 << j
        // Check whether the value in the position is 1
        if ((xy(i) & mask) != 0) { // Do bit shuffling
          res |= 1 << (i + j * 2)
        }
      }
    }
    String.valueOf(res)
  }

  /**
   * 经度转行
   *
   * @param lon  经度
   * @param zoom 层级
   * @return x
   */
  def lon2Tile(lon: Double, zoom: Int): Int = Math.floor((lon + 180) / 360 * Math.pow(2, zoom)).toInt

  /**
   * 纬度转列
   *
   * @param lat  纬度
   * @param zoom 层级
   * @return y
   */
  def lat2Tile(lat: Double, zoom: Int): Int = {
    val n: Double = Math.pow(2, zoom)
    Math.floor((1 - (Math.log(Math.tan(Math.toRadians(lat)) + (1 / Math.cos(Math.toRadians(lat)))) / Math.PI)) / 2 * n).toInt
    //        return (int) Math.floor(1 - Math.log(Math.tan(lat * Math.PI / 180) +
    //                1 / Math.cos(lat * Math.PI / 180)) / Math.PI / 2 * Math.pow(2, zoom));
  }

  /**
   * x 转经度
   * 这里的经纬度都是左上角的
   *
   * @param x    瓦片x编号
   * @param zoom 层级
   * @return 左上角经度
   */
  def tile2Lon(x: Int, zoom: Int): Double = x / Math.pow(2, zoom) * 360 - 180

  /**
   * y 转纬度
   * 这里的经纬度都是左上角的
   *
   * @param y    瓦片y编号
   * @param zoom 层级
   * @return 左上角纬度
   */
  def tile2Lat(y: Int, zoom: Int): Double = {
    val n: Double = Math.PI - 2 * Math.PI * y / Math.pow(2, zoom)
    180 / Math.PI * Math.atan(0.5 * (Math.exp(n) - Math.exp(-n)))
  }

  /**
   * 根据索引进行z曲线编码
   *
   * @param x    瓦片 x 编号
   * @param y    瓦片 y 编号
   * @param zoom 层级
   * @return 编码结果
   */
  def xyToZCurve(x: Int, y: Int, zoom: Int): String = {
    val xy: Array[Int] = Array[Int](x, y)
    var res = 0
    for (i <- 0 until 2) {
      for (j <- 0 until zoom) {
        val mask: Int = 1 << j
        if ((xy(i) & mask) != 0) res |= 1 << (i + j * 2)
      }
    }
    String.valueOf(res)
  }

  def zCurveToXY(zIndexStr: String, zoom: Int): Array[Int] = {
    val zIndex: Int = zIndexStr.toInt
    val xy: Array[Int] = Array[Int](0, 0)
    for (i <- 0 until 2) {
      for (j <- 0 until zoom) { // Task 1.1 zorder，修改以下代码
        val mask: Int = 1 << j * 2 + i
        if ((zIndex & mask) != 0) xy(i) |= 1 << j
      }
    }
    xy
  }

  def zCurveToXY(zIndex: Int, zoom: Int): Array[Int] = {
    val xy: Array[Int] = Array[Int](0, 0)
    for (i <- 0 until 2) {
      for (j <- 0 until zoom) { // Task 1.1 zorder，修改以下代码
        val mask: Int = 1 << j * 2 + i
        if ((zIndex & mask) != 0) xy(i) |= 1 << j
      }
    }
    xy
  }

  def zCurveToLonLat(zIndexStr: String, zoom: Int): Array[Double] = {
    val xy: Array[Int] = zCurveToXY(zIndexStr, zoom)
    Array[Double](tile2Lon(xy(0), zoom), tile2Lat(xy(0), zoom))
  }

  def extentStitcher(extent: Array[Extent]): Extent = {
    val extentTuple: (Double, Double, Double, Double) = extent.map(t => (t.xmin, t.ymin, t.xmax, t.ymax)).reduce((a, b) => {
      (math.min(a._1, b._1), math.min(a._2, b._2), math.max(a._3, b._3), math.max(a._4, b._4))
    })
    Extent(extentTuple._1, extentTuple._2, extentTuple._3, extentTuple._4)
  }

}
